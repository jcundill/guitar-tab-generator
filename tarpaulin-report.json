{"files":[{"path":["C:","\\","Users","Noah","Documents","GitHub","guitar-tab-generator","src","arrangement.rs"],"content":"use crate::{\r\n    guitar::{generate_pitch_fingerings, PitchFingering},\r\n    Guitar, Pitch,\r\n};\r\nuse anyhow::{anyhow, Result};\r\nuse average::Mean;\r\nuse itertools::Itertools;\r\nuse ordered_float::OrderedFloat;\r\nuse pathfinding::prelude::dijkstra;\r\nuse std::collections::HashSet;\r\n\r\n#[derive(Debug)]\r\npub struct InvalidInput {\r\n    value: String,\r\n    line_number: u16,\r\n}\r\n\r\n#[derive(Debug, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]\r\npub enum Line<T> {\r\n    MeasureBreak,\r\n    Rest,\r\n    Playable(T),\r\n}\r\nuse Line::{MeasureBreak, Playable, Rest};\r\n\r\n#[derive(Debug, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]\r\nenum Node {\r\n    Start,\r\n    Rest {\r\n        line_index: u16,\r\n    },\r\n    Note {\r\n        line_index: u16,\r\n        beat_fingering_combo: BeatFingeringCombo,\r\n    },\r\n}\r\n\r\npub type PitchVec<T> = Vec<T>;\r\ntype BeatVec<T> = Vec<T>;\r\n\r\n#[derive(Debug, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]\r\n#[allow(dead_code)]\r\npub struct BeatFingeringCombo {\r\n    fingering_combo: BeatVec<PitchFingering>,\r\n    non_zero_avg_fret: OrderedFloat<f32>,\r\n    non_zero_fret_span: u8,\r\n}\r\nimpl BeatFingeringCombo {\r\n    pub fn new(beat_fingering_candidate: BeatVec<&PitchFingering>) -> Self {\r\n        BeatFingeringCombo {\r\n            fingering_combo: beat_fingering_candidate\r\n                .clone()\r\n                .into_iter()\r\n                .cloned()\r\n                .collect(),\r\n            non_zero_avg_fret: OrderedFloat(\r\n                beat_fingering_candidate\r\n                    .clone()\r\n                    .iter()\r\n                    .filter(|fingering| fingering.fret != 0)\r\n                    .map(|fingering| fingering.fret as f64)\r\n                    .collect::<Mean>()\r\n                    .mean() as f32,\r\n            ),\r\n\r\n            non_zero_fret_span: calc_fret_span(beat_fingering_candidate).unwrap_or(0),\r\n        }\r\n    }\r\n}\r\n#[cfg(test)]\r\nmod test_create_beat_fingering_combo {\r\n    use super::*;\r\n    use crate::StringNumber;\r\n\r\n    #[test]\r\n    fn simple() {\r\n        let pitch_fingering_1 = PitchFingering {\r\n            pitch: Pitch::A0,\r\n            string_number: StringNumber::new(1).unwrap(),\r\n            fret: 2,\r\n        };\r\n\r\n        let BeatFingeringCombo {\r\n            fingering_combo,\r\n            non_zero_avg_fret,\r\n            non_zero_fret_span,\r\n        } = BeatFingeringCombo::new(vec![&pitch_fingering_1]);\r\n\r\n        assert_eq!(fingering_combo, vec![pitch_fingering_1]);\r\n        assert_eq!(non_zero_avg_fret, 2.0);\r\n        assert_eq!(non_zero_fret_span, 0);\r\n    }\r\n    #[test]\r\n    fn complex() {\r\n        let pitch_fingering_1 = PitchFingering {\r\n            pitch: Pitch::A0,\r\n            string_number: StringNumber::new(1).unwrap(),\r\n            fret: 2,\r\n        };\r\n        let pitch_fingering_2 = PitchFingering {\r\n            pitch: Pitch::B1,\r\n            string_number: StringNumber::new(2).unwrap(),\r\n            fret: 5,\r\n        };\r\n        let pitch_fingering_3 = PitchFingering {\r\n            pitch: Pitch::C2,\r\n            string_number: StringNumber::new(3).unwrap(),\r\n            fret: 0,\r\n        };\r\n        let pitch_fingering_4 = PitchFingering {\r\n            pitch: Pitch::D3,\r\n            string_number: StringNumber::new(4).unwrap(),\r\n            fret: 1,\r\n        };\r\n\r\n        let BeatFingeringCombo {\r\n            fingering_combo,\r\n            non_zero_avg_fret,\r\n            non_zero_fret_span,\r\n        } = BeatFingeringCombo::new(vec![\r\n            &pitch_fingering_1,\r\n            &pitch_fingering_2,\r\n            &pitch_fingering_3,\r\n            &pitch_fingering_4,\r\n        ]);\r\n\r\n        assert_eq!(\r\n            fingering_combo,\r\n            vec![\r\n                pitch_fingering_1,\r\n                pitch_fingering_2,\r\n                pitch_fingering_3,\r\n                pitch_fingering_4\r\n            ]\r\n        );\r\n        assert_eq!(non_zero_avg_fret, 8.0 / 3.0);\r\n        assert_eq!(non_zero_fret_span, 4);\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\npub struct Arrangement {}\r\n\r\nimpl Arrangement {\r\n    pub fn new(guitar: Guitar, input_pitches: Vec<Line<BeatVec<Pitch>>>) -> Result<Self> {\r\n        let pitch_fingering_candidates: Vec<Line<BeatVec<PitchVec<PitchFingering>>>> =\r\n            validate_fingerings(&guitar, &input_pitches)?;\r\n\r\n        let measure_break_indices = pitch_fingering_candidates\r\n            .iter()\r\n            .enumerate()\r\n            .filter(|(.., line_candidate)| line_candidate == &&MeasureBreak)\r\n            .map(|(line_index, ..)| line_index);\r\n\r\n        let path_node_groups: Vec<BeatVec<Node>> = pitch_fingering_candidates\r\n            .iter()\r\n            .filter(|&line_candidate| line_candidate != &MeasureBreak)\r\n            .enumerate()\r\n            .map(|(line_index, line_candidate)| match line_candidate {\r\n                MeasureBreak => vec![],\r\n                Rest => vec![Node::Rest {\r\n                    line_index: line_index as u16,\r\n                }],\r\n                Playable(beat_fingerings_per_pitch) => {\r\n                    generate_fingering_combos(beat_fingerings_per_pitch)\r\n                        .iter()\r\n                        .map(|pitch_fingering_group| Node::Note {\r\n                            line_index: line_index as u16,\r\n                            beat_fingering_combo: BeatFingeringCombo::new(\r\n                                pitch_fingering_group.to_vec(),\r\n                            ),\r\n                        })\r\n                        .collect()\r\n                }\r\n            })\r\n            .collect();\r\n\r\n        let num_path_node_groups = path_node_groups.len();\r\n\r\n        let path_nodes: Vec<Node> = path_node_groups.into_iter().flatten().collect_vec();\r\n        let path_result = dijkstra(\r\n            &Node::Start,\r\n            |current_node| calc_next_nodes(current_node, path_nodes.clone()),\r\n            |current_node| match current_node {\r\n                Node::Start => false,\r\n                Node::Rest { line_index } | Node::Note { line_index, .. } => {\r\n                    // Pathfinding goal is reached when the node is in the last node group\r\n                    *line_index == (num_path_node_groups - 1) as u16\r\n                }\r\n            },\r\n        );\r\n\r\n        let mut path_lines: Vec<Line<BeatVec<PitchFingering>>> = path_result\r\n            .expect(\"Path should exist.\")\r\n            .0\r\n            .into_iter()\r\n            .filter(|node| node != &Node::Start)\r\n            .map(|node| match node {\r\n                Node::Start => unreachable!(\"Start node should already have been filtered out.\"),\r\n                Node::Rest { .. } => Line::Rest,\r\n                Node::Note {\r\n                    beat_fingering_combo,\r\n                    ..\r\n                } => Line::Playable(beat_fingering_combo.fingering_combo),\r\n            })\r\n            .collect_vec();\r\n\r\n        // Add measure breaks back in\r\n        for measure_break_index in measure_break_indices.sorted() {\r\n            path_lines.insert(measure_break_index, Line::MeasureBreak);\r\n        }\r\n\r\n        dbg!(&path_lines);\r\n\r\n        // const WARNING_FRET_SPAN: u8 = 4;\r\n\r\n        Ok(Arrangement {})\r\n    }\r\n}\r\n\r\n/// Generates fingerings for each pitch, and returns a result containing the fingerings or\r\n/// an error message if any impossible pitches (with no fingerings) are found.\r\n///\r\n/// Arguments:\r\n///\r\n/// * `guitar`: A reference to a `Guitar` object, which contains information about the guitar's\r\n/// string ranges.\r\n/// * `input_pitches`: A slice of vectors, where each vector represents a beat and contains a\r\n/// vector of pitches.\r\n///\r\n/// Returns a `Result` containing either a\r\n/// `Vec<Vec<Vec<Fingering>>>` if the input pitches are valid, or an `Err` containing an error\r\n/// message if there are invalid pitches.\r\nfn validate_fingerings(\r\n    guitar: &Guitar,\r\n    input_pitches: &[Line<BeatVec<Pitch>>],\r\n) -> Result<Vec<Line<BeatVec<PitchVec<PitchFingering>>>>> {\r\n    let mut impossible_pitches: Vec<InvalidInput> = vec![];\r\n    let fingerings: Vec<Line<BeatVec<PitchVec<PitchFingering>>>> = input_pitches\r\n        .iter()\r\n        .enumerate()\r\n        .map(|(beat_index, beat_input)| match beat_input {\r\n            MeasureBreak => MeasureBreak,\r\n            Rest => Rest,\r\n            Playable(beat_pitches) => Playable(\r\n                beat_pitches\r\n                    .iter()\r\n                    .map(|beat_pitch| {\r\n                        let pitch_fingerings: PitchVec<PitchFingering> =\r\n                            generate_pitch_fingerings(&guitar.string_ranges, beat_pitch);\r\n                        if pitch_fingerings.is_empty() {\r\n                            impossible_pitches.push(InvalidInput {\r\n                                value: format!(\"{:?}\", beat_pitch),\r\n                                line_number: (beat_index as u16) + 1,\r\n                            })\r\n                        }\r\n                        pitch_fingerings\r\n                    })\r\n                    .collect(),\r\n            ),\r\n        })\r\n        .collect();\r\n\r\n    if !impossible_pitches.is_empty() {\r\n        let error_string = impossible_pitches\r\n            .iter()\r\n            .map(|invalid_input| {\r\n                format!(\r\n                    \"Pitch {} on line {} cannot be played on any strings of the configured guitar.\",\r\n                    invalid_input.value, invalid_input.line_number\r\n                )\r\n            })\r\n            .collect::<Vec<String>>()\r\n            .join(\"\\n\");\r\n\r\n        return Err(anyhow!(error_string));\r\n    }\r\n\r\n    Ok(fingerings)\r\n}\r\n#[cfg(test)]\r\nmod test_validate_fingerings {\r\n    use super::*;\r\n    use crate::StringNumber;\r\n    use std::collections::{BTreeMap, HashSet};\r\n\r\n    fn generate_standard_guitar() -> Guitar {\r\n        Guitar {\r\n            tuning: BTreeMap::from([\r\n                (StringNumber::new(1).unwrap(), Pitch::E4),\r\n                (StringNumber::new(2).unwrap(), Pitch::B3),\r\n                (StringNumber::new(3).unwrap(), Pitch::G3),\r\n                (StringNumber::new(4).unwrap(), Pitch::D3),\r\n                (StringNumber::new(5).unwrap(), Pitch::A2),\r\n                (StringNumber::new(6).unwrap(), Pitch::E2),\r\n            ]),\r\n            num_frets: 12,\r\n            range: HashSet::from([\r\n                Pitch::E2,\r\n                Pitch::F2,\r\n                Pitch::FSharp2,\r\n                Pitch::G2,\r\n                Pitch::A2,\r\n                Pitch::ASharp2,\r\n                Pitch::B2,\r\n                Pitch::C3,\r\n                Pitch::D3,\r\n                Pitch::DSharp3,\r\n                Pitch::E3,\r\n                Pitch::F3,\r\n                Pitch::G3,\r\n                Pitch::GSharp3,\r\n                Pitch::A3,\r\n                Pitch::ASharp3,\r\n                Pitch::B3,\r\n                Pitch::C4,\r\n                Pitch::CSharp4,\r\n                Pitch::D4,\r\n                Pitch::E4,\r\n                Pitch::F4,\r\n                Pitch::FSharp4,\r\n                Pitch::G4,\r\n            ]),\r\n            string_ranges: BTreeMap::from([\r\n                (\r\n                    StringNumber::new(1).unwrap(),\r\n                    vec![Pitch::E4, Pitch::F4, Pitch::FSharp4, Pitch::G4],\r\n                ),\r\n                (\r\n                    StringNumber::new(2).unwrap(),\r\n                    vec![Pitch::B3, Pitch::C4, Pitch::CSharp4, Pitch::D4],\r\n                ),\r\n                (\r\n                    StringNumber::new(3).unwrap(),\r\n                    vec![Pitch::G3, Pitch::GSharp3, Pitch::A3, Pitch::ASharp3],\r\n                ),\r\n                (\r\n                    StringNumber::new(4).unwrap(),\r\n                    vec![Pitch::D3, Pitch::DSharp3, Pitch::E3, Pitch::F3],\r\n                ),\r\n                (\r\n                    StringNumber::new(5).unwrap(),\r\n                    vec![Pitch::A2, Pitch::ASharp2, Pitch::B2, Pitch::C3],\r\n                ),\r\n                (\r\n                    StringNumber::new(6).unwrap(),\r\n                    vec![Pitch::E2, Pitch::F2, Pitch::FSharp2, Pitch::G2],\r\n                ),\r\n            ]),\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn valid_simple() {\r\n        let guitar = generate_standard_guitar();\r\n        let input_pitches = vec![Playable(vec![Pitch::G3])];\r\n        let expected_fingerings = vec![Playable(vec![generate_pitch_fingerings(\r\n            &guitar.string_ranges,\r\n            &Pitch::G3,\r\n        )])];\r\n\r\n        assert_eq!(\r\n            validate_fingerings(&guitar, &input_pitches).unwrap(),\r\n            expected_fingerings\r\n        );\r\n    }\r\n    #[test]\r\n    fn valid_complex() {\r\n        let guitar = generate_standard_guitar();\r\n        let input_pitches = vec![\r\n            Playable(vec![Pitch::G3]),\r\n            MeasureBreak,\r\n            Playable(vec![Pitch::B3]),\r\n            Rest,\r\n            Playable(vec![Pitch::D4, Pitch::G4]),\r\n        ];\r\n        let expected_fingerings = vec![\r\n            Playable(vec![generate_pitch_fingerings(\r\n                &guitar.string_ranges,\r\n                &Pitch::G3,\r\n            )]),\r\n            MeasureBreak,\r\n            Playable(vec![generate_pitch_fingerings(\r\n                &guitar.string_ranges,\r\n                &Pitch::B3,\r\n            )]),\r\n            Rest,\r\n            Playable(vec![\r\n                generate_pitch_fingerings(&guitar.string_ranges, &Pitch::D4),\r\n                generate_pitch_fingerings(&guitar.string_ranges, &Pitch::G4),\r\n            ]),\r\n        ];\r\n\r\n        assert_eq!(\r\n            validate_fingerings(&guitar, &input_pitches).unwrap(),\r\n            expected_fingerings\r\n        );\r\n    }\r\n    #[test]\r\n    fn invalid_simple() {\r\n        let guitar = generate_standard_guitar();\r\n        let input_pitches = vec![Playable(vec![Pitch::B9])];\r\n\r\n        let error = validate_fingerings(&guitar, &input_pitches).unwrap_err();\r\n        let error_string = format!(\"{error}\");\r\n        let expected_error_string =\r\n            \"Pitch B9 on line 1 cannot be played on any strings of the configured guitar.\";\r\n        assert_eq!(error_string, expected_error_string);\r\n    }\r\n    #[test]\r\n    fn invalid_complex() {\r\n        let guitar = generate_standard_guitar();\r\n        let input_pitches = vec![\r\n            Playable(vec![Pitch::A1]),\r\n            Playable(vec![Pitch::G3]),\r\n            Playable(vec![Pitch::B3]),\r\n            Playable(vec![Pitch::A1, Pitch::B1]),\r\n            Playable(vec![Pitch::G3, Pitch::D2]),\r\n            Playable(vec![Pitch::D4, Pitch::G4]),\r\n        ];\r\n\r\n        let error = validate_fingerings(&guitar, &input_pitches).unwrap_err();\r\n        let error_string = format!(\"{error}\");\r\n        let expected_error_string =\r\n            \"Pitch A1 on line 1 cannot be played on any strings of the configured guitar.\\n\\\r\n            Pitch A1 on line 4 cannot be played on any strings of the configured guitar.\\n\\\r\n            Pitch B1 on line 4 cannot be played on any strings of the configured guitar.\\n\\\r\n            Pitch D2 on line 5 cannot be played on any strings of the configured guitar.\";\r\n        assert_eq!(error_string, expected_error_string);\r\n    }\r\n}\r\n\r\n/// Generates all playable combinations of fingerings for all the pitches in a beat.\r\nfn generate_fingering_combos(\r\n    beat_fingerings_per_pitch: &[Vec<PitchFingering>],\r\n) -> Vec<BeatVec<&PitchFingering>> {\r\n    if beat_fingerings_per_pitch.is_empty() {\r\n        unreachable!(\"Beat pitch fingerings should not be empty.\")\r\n    }\r\n\r\n    beat_fingerings_per_pitch\r\n        .iter()\r\n        .multi_cartesian_product()\r\n        .filter(no_duplicate_strings)\r\n        .collect_vec()\r\n}\r\n#[cfg(test)]\r\nmod test_generate_fingering_combos {\r\n    use super::*;\r\n    use crate::StringNumber;\r\n\r\n    #[test]\r\n    fn simple() {\r\n        let pitch_fingering = PitchFingering {\r\n            pitch: Pitch::B6,\r\n            string_number: StringNumber::new(2).unwrap(),\r\n            fret: 3,\r\n        };\r\n\r\n        let beat_fingerings_per_pitch = vec![vec![pitch_fingering]];\r\n        let expected_fingering_combos = vec![vec![&pitch_fingering]];\r\n\r\n        assert_eq!(\r\n            generate_fingering_combos(&beat_fingerings_per_pitch),\r\n            expected_fingering_combos\r\n        );\r\n    }\r\n    #[test]\r\n    fn complex() {\r\n        let pitch_fingering_a_string_2 = PitchFingering {\r\n            pitch: Pitch::B6,\r\n            string_number: StringNumber::new(2).unwrap(),\r\n            fret: 3,\r\n        };\r\n        let pitch_fingering_a_string_3 = PitchFingering {\r\n            pitch: Pitch::B6,\r\n            string_number: StringNumber::new(3).unwrap(),\r\n            fret: 8,\r\n        };\r\n        let pitch_fingering_b_string_2 = PitchFingering {\r\n            pitch: Pitch::C7,\r\n            string_number: StringNumber::new(2).unwrap(),\r\n            fret: 4,\r\n        };\r\n        let pitch_fingering_b_string_3 = PitchFingering {\r\n            pitch: Pitch::C7,\r\n            string_number: StringNumber::new(3).unwrap(),\r\n            fret: 9,\r\n        };\r\n        let pitch_fingering_b_string_4 = PitchFingering {\r\n            pitch: Pitch::C7,\r\n            string_number: StringNumber::new(4).unwrap(),\r\n            fret: 14,\r\n        };\r\n\r\n        let beat_fingerings_per_pitch = vec![\r\n            vec![pitch_fingering_a_string_2, pitch_fingering_a_string_3],\r\n            vec![\r\n                pitch_fingering_b_string_2,\r\n                pitch_fingering_b_string_3,\r\n                pitch_fingering_b_string_4,\r\n            ],\r\n        ];\r\n        let expected_fingering_combos = vec![\r\n            vec![&pitch_fingering_a_string_2, &pitch_fingering_b_string_3],\r\n            vec![&pitch_fingering_a_string_2, &pitch_fingering_b_string_4],\r\n            vec![&pitch_fingering_a_string_3, &pitch_fingering_b_string_2],\r\n            vec![&pitch_fingering_a_string_3, &pitch_fingering_b_string_4],\r\n        ];\r\n\r\n        assert_eq!(\r\n            generate_fingering_combos(&beat_fingerings_per_pitch),\r\n            expected_fingering_combos\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[should_panic]\r\n    fn empty_input() {\r\n        generate_fingering_combos(&[]);\r\n    }\r\n}\r\n\r\n/// Checks if there are any duplicate strings in a vector of `Fingering`\r\n/// objects to ensure that all pitches can be played.\r\nfn no_duplicate_strings(beat_fingering_option: &Vec<&PitchFingering>) -> bool {\r\n    let num_pitches = beat_fingering_option.len();\r\n    let num_strings = beat_fingering_option\r\n        .iter()\r\n        .map(|fingering| fingering.string_number)\r\n        .collect::<HashSet<_>>()\r\n        .len();\r\n\r\n    num_pitches == num_strings\r\n}\r\n#[cfg(test)]\r\nmod test_no_duplicate_strings {\r\n    use super::*;\r\n    use crate::StringNumber;\r\n\r\n    #[test]\r\n    fn valid_simple() {\r\n        let fingering_1 = PitchFingering {\r\n            pitch: Pitch::B6,\r\n            string_number: StringNumber::new(2).unwrap(),\r\n            fret: 3,\r\n        };\r\n        let beat_fingering_option: &Vec<&PitchFingering> = &vec![&fingering_1];\r\n\r\n        assert!(no_duplicate_strings(beat_fingering_option));\r\n    }\r\n    #[test]\r\n    fn valid_complex() {\r\n        let fingering_1 = PitchFingering {\r\n            pitch: Pitch::CSharp2,\r\n            string_number: StringNumber::new(1).unwrap(),\r\n            fret: 1,\r\n        };\r\n        let fingering_2 = PitchFingering {\r\n            pitch: Pitch::F4,\r\n            string_number: StringNumber::new(2).unwrap(),\r\n            fret: 3,\r\n        };\r\n        let fingering_3 = PitchFingering {\r\n            pitch: Pitch::A5,\r\n            string_number: StringNumber::new(4).unwrap(),\r\n            fret: 4,\r\n        };\r\n        let fingering_4 = PitchFingering {\r\n            pitch: Pitch::DSharp6,\r\n            string_number: StringNumber::new(11).unwrap(),\r\n            fret: 0,\r\n        };\r\n        let beat_fingering_option: &Vec<&PitchFingering> =\r\n            &vec![&fingering_1, &fingering_2, &fingering_3, &fingering_4];\r\n\r\n        assert!(no_duplicate_strings(beat_fingering_option));\r\n    }\r\n    #[test]\r\n    fn invalid_simple() {\r\n        let fingering_1 = PitchFingering {\r\n            pitch: Pitch::CSharp2,\r\n            string_number: StringNumber::new(4).unwrap(),\r\n            fret: 1,\r\n        };\r\n        let fingering_2 = PitchFingering {\r\n            pitch: Pitch::F4,\r\n            string_number: StringNumber::new(4).unwrap(),\r\n            fret: 3,\r\n        };\r\n        let beat_fingering_option: &Vec<&PitchFingering> = &vec![&fingering_1, &fingering_2];\r\n\r\n        assert!(!no_duplicate_strings(beat_fingering_option));\r\n    }\r\n    #[test]\r\n    fn invalid_complex() {\r\n        let fingering_1 = PitchFingering {\r\n            pitch: Pitch::CSharp2,\r\n            string_number: StringNumber::new(1).unwrap(),\r\n            fret: 1,\r\n        };\r\n        let fingering_2 = PitchFingering {\r\n            pitch: Pitch::F4,\r\n            string_number: StringNumber::new(3).unwrap(),\r\n            fret: 3,\r\n        };\r\n        let fingering_3 = PitchFingering {\r\n            pitch: Pitch::A5,\r\n            string_number: StringNumber::new(6).unwrap(),\r\n            fret: 4,\r\n        };\r\n        let fingering_4 = PitchFingering {\r\n            pitch: Pitch::DSharp6,\r\n            string_number: StringNumber::new(3).unwrap(),\r\n            fret: 0,\r\n        };\r\n        let beat_fingering_option: &Vec<&PitchFingering> =\r\n            &vec![&fingering_1, &fingering_2, &fingering_3, &fingering_4];\r\n\r\n        assert!(!no_duplicate_strings(beat_fingering_option));\r\n    }\r\n    #[test]\r\n    fn empty_input() {\r\n        assert!(no_duplicate_strings(&vec![]));\r\n    }\r\n}\r\n\r\n/// Calculates the difference between the maximum and minimum non-zero\r\n/// fret numbers in a given vector of fingerings.\r\nfn calc_fret_span(beat_fingering_candidate: Vec<&PitchFingering>) -> Option<u8> {\r\n    let beat_fingering_option_fret_numbers = beat_fingering_candidate\r\n        .iter()\r\n        .filter(|fingering| fingering.fret != 0)\r\n        .map(|fingering| fingering.fret);\r\n\r\n    let min_non_zero_fret = match beat_fingering_option_fret_numbers.clone().min() {\r\n        None => return None,\r\n        Some(fret_num) => fret_num,\r\n    };\r\n    let max_non_zero_fret = match beat_fingering_option_fret_numbers.clone().max() {\r\n        None => unreachable!(\"A maximum should exist if a minimum exists.\"),\r\n        Some(fret_num) => fret_num,\r\n    };\r\n\r\n    Some(max_non_zero_fret - min_non_zero_fret)\r\n}\r\n#[cfg(test)]\r\nmod test_calc_fret_span {\r\n    use super::*;\r\n    use crate::StringNumber;\r\n\r\n    #[test]\r\n    fn simple() {\r\n        let fingering_1 = PitchFingering {\r\n            pitch: Pitch::B6,\r\n            string_number: StringNumber::new(2).unwrap(),\r\n            fret: 3,\r\n        };\r\n\r\n        assert_eq!(calc_fret_span(vec![&fingering_1]).unwrap(), 0);\r\n    }\r\n    #[test]\r\n    fn complex() {\r\n        let fingering_1 = PitchFingering {\r\n            pitch: Pitch::CSharp2,\r\n            string_number: StringNumber::new(1).unwrap(),\r\n            fret: 1,\r\n        };\r\n        let fingering_2 = PitchFingering {\r\n            pitch: Pitch::F4,\r\n            string_number: StringNumber::new(2).unwrap(),\r\n            fret: 3,\r\n        };\r\n        let fingering_3 = PitchFingering {\r\n            pitch: Pitch::A5,\r\n            string_number: StringNumber::new(4).unwrap(),\r\n            fret: 4,\r\n        };\r\n        let fingering_4 = PitchFingering {\r\n            pitch: Pitch::DSharp6,\r\n            string_number: StringNumber::new(11).unwrap(),\r\n            fret: 0,\r\n        };\r\n        let beat_fingering_option: Vec<&PitchFingering> =\r\n            vec![&fingering_1, &fingering_2, &fingering_3, &fingering_4];\r\n\r\n        assert_eq!(calc_fret_span(beat_fingering_option).unwrap(), 3);\r\n    }\r\n    #[test]\r\n    fn empty_input() {\r\n        assert!(calc_fret_span(vec![]).is_none());\r\n    }\r\n}\r\n\r\n/// Calculates the next nodes and their costs based on the current node and a\r\n/// list of all path nodes.\r\n///\r\n/// Returns a vector of tuples, where each tuple contains a `Node` the `i16`\r\n/// cost of moving to that node.\r\nfn calc_next_nodes(current_node: &Node, path_nodes: Vec<Node>) -> Vec<(Node, i16)> {\r\n    let next_node_index = match current_node {\r\n        Node::Start => 0,\r\n        Node::Rest { line_index } | Node::Note { line_index, .. } => line_index + 1,\r\n    };\r\n\r\n    let next_nodes = path_nodes\r\n        .iter()\r\n        .filter(|&node| {\r\n            next_node_index\r\n                == match node {\r\n                    Node::Start => unreachable!(\"Start should never be a future node.\"),\r\n                    Node::Rest { line_index } | Node::Note { line_index, .. } => *line_index,\r\n                }\r\n        })\r\n        .map(|next_node| {\r\n            (\r\n                next_node.clone(),\r\n                calculate_node_cost(current_node, next_node),\r\n            )\r\n        })\r\n        .collect_vec();\r\n\r\n    next_nodes\r\n}\r\n#[cfg(test)]\r\nmod test_calc_next_nodes {\r\n    use super::*;\r\n\r\n    fn create_test_path_nodes() -> Vec<Node> {\r\n        vec![\r\n            Node::Note {\r\n                line_index: 0,\r\n                beat_fingering_combo: BeatFingeringCombo {\r\n                    fingering_combo: vec![],\r\n                    non_zero_avg_fret: OrderedFloat(0.1),\r\n                    non_zero_fret_span: 0,\r\n                },\r\n            },\r\n            Node::Note {\r\n                line_index: 0,\r\n                beat_fingering_combo: BeatFingeringCombo {\r\n                    fingering_combo: vec![],\r\n                    non_zero_avg_fret: OrderedFloat(0.2),\r\n                    non_zero_fret_span: 0,\r\n                },\r\n            },\r\n            Node::Note {\r\n                line_index: 1,\r\n                beat_fingering_combo: BeatFingeringCombo {\r\n                    fingering_combo: vec![],\r\n                    non_zero_avg_fret: OrderedFloat(1.1),\r\n                    non_zero_fret_span: 1,\r\n                },\r\n            },\r\n            Node::Rest { line_index: 2 },\r\n            Node::Rest { line_index: 3 },\r\n            Node::Note {\r\n                line_index: 4,\r\n                beat_fingering_combo: BeatFingeringCombo {\r\n                    fingering_combo: vec![],\r\n                    non_zero_avg_fret: OrderedFloat(4.1),\r\n                    non_zero_fret_span: 4,\r\n                },\r\n            },\r\n            Node::Note {\r\n                line_index: 4,\r\n                beat_fingering_combo: BeatFingeringCombo {\r\n                    fingering_combo: vec![],\r\n                    non_zero_avg_fret: OrderedFloat(4.1),\r\n                    non_zero_fret_span: 4,\r\n                },\r\n            },\r\n        ]\r\n    }\r\n\r\n    #[test]\r\n    fn from_start_to_note() {\r\n        let current_node = Node::Start;\r\n\r\n        let expected_nodes_and_costs = vec![\r\n            Node::Note {\r\n                line_index: 0,\r\n                beat_fingering_combo: BeatFingeringCombo {\r\n                    fingering_combo: vec![],\r\n                    non_zero_avg_fret: OrderedFloat(0.1),\r\n                    non_zero_fret_span: 0,\r\n                },\r\n            },\r\n            Node::Note {\r\n                line_index: 0,\r\n                beat_fingering_combo: BeatFingeringCombo {\r\n                    fingering_combo: vec![],\r\n                    non_zero_avg_fret: OrderedFloat(0.2),\r\n                    non_zero_fret_span: 0,\r\n                },\r\n            },\r\n        ]\r\n        .iter()\r\n        .map(|node| (node.clone(), calculate_node_cost(&current_node, node)))\r\n        .collect_vec();\r\n\r\n        assert_eq!(\r\n            calc_next_nodes(&current_node, create_test_path_nodes()),\r\n            expected_nodes_and_costs\r\n        );\r\n    }\r\n    #[test]\r\n    fn from_note_to_note() {\r\n        let current_node = Node::Note {\r\n            line_index: 0,\r\n            beat_fingering_combo: BeatFingeringCombo {\r\n                fingering_combo: vec![],\r\n                non_zero_avg_fret: OrderedFloat(0.1),\r\n                non_zero_fret_span: 0,\r\n            },\r\n        };\r\n\r\n        let expected_nodes_and_costs = vec![Node::Note {\r\n            line_index: 1,\r\n            beat_fingering_combo: BeatFingeringCombo {\r\n                fingering_combo: vec![],\r\n                non_zero_avg_fret: OrderedFloat(1.1),\r\n                non_zero_fret_span: 1,\r\n            },\r\n        }]\r\n        .iter()\r\n        .map(|node| (node.clone(), calculate_node_cost(&current_node, node)))\r\n        .collect_vec();\r\n\r\n        assert_eq!(\r\n            calc_next_nodes(&current_node, create_test_path_nodes()),\r\n            expected_nodes_and_costs\r\n        );\r\n    }\r\n    #[test]\r\n    fn from_note_to_rest() {\r\n        let current_node = Node::Note {\r\n            line_index: 1,\r\n            beat_fingering_combo: BeatFingeringCombo {\r\n                fingering_combo: vec![],\r\n                non_zero_avg_fret: OrderedFloat(1.1),\r\n                non_zero_fret_span: 1,\r\n            },\r\n        };\r\n\r\n        let expected_nodes_and_costs = vec![Node::Rest { line_index: 2 }]\r\n            .iter()\r\n            .map(|node| (node.clone(), calculate_node_cost(&current_node, node)))\r\n            .collect_vec();\r\n\r\n        assert_eq!(\r\n            calc_next_nodes(&current_node, create_test_path_nodes()),\r\n            expected_nodes_and_costs\r\n        );\r\n    }\r\n    #[test]\r\n    fn from_rest_to_rest() {\r\n        let current_node = Node::Rest { line_index: 2 };\r\n\r\n        let expected_nodes_and_costs = vec![Node::Rest { line_index: 3 }]\r\n            .iter()\r\n            .map(|node| (node.clone(), calculate_node_cost(&current_node, node)))\r\n            .collect_vec();\r\n\r\n        assert_eq!(\r\n            calc_next_nodes(&current_node, create_test_path_nodes()),\r\n            expected_nodes_and_costs\r\n        );\r\n    }\r\n    #[test]\r\n    fn from_rest_to_note() {\r\n        let current_node = Node::Rest { line_index: 3 };\r\n\r\n        let expected_nodes_and_costs = vec![\r\n            Node::Note {\r\n                line_index: 4,\r\n                beat_fingering_combo: BeatFingeringCombo {\r\n                    fingering_combo: vec![],\r\n                    non_zero_avg_fret: OrderedFloat(4.1),\r\n                    non_zero_fret_span: 4,\r\n                },\r\n            },\r\n            Node::Note {\r\n                line_index: 4,\r\n                beat_fingering_combo: BeatFingeringCombo {\r\n                    fingering_combo: vec![],\r\n                    non_zero_avg_fret: OrderedFloat(4.1),\r\n                    non_zero_fret_span: 4,\r\n                },\r\n            },\r\n        ]\r\n        .iter()\r\n        .map(|node| (node.clone(), calculate_node_cost(&current_node, node)))\r\n        .collect_vec();\r\n\r\n        assert_eq!(\r\n            calc_next_nodes(&current_node, create_test_path_nodes()),\r\n            expected_nodes_and_costs\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[should_panic]\r\n    fn to_start() {\r\n        calc_next_nodes(\r\n            &Node::Rest { line_index: 3 },\r\n            vec![Node::Rest { line_index: 4 }, Node::Start],\r\n        );\r\n    }\r\n}\r\n\r\n/// Calculates the cost of transitioning from one node to another based on the\r\n/// average fret difference and fret span.\r\nfn calculate_node_cost(current_node: &Node, next_node: &Node) -> i16 {\r\n    let current_avg_fret = match current_node {\r\n        Node::Start => return 0,\r\n        Node::Rest { .. } => return 0,\r\n        Node::Note {\r\n            beat_fingering_combo,\r\n            ..\r\n        } => beat_fingering_combo.non_zero_avg_fret,\r\n    };\r\n\r\n    let (next_avg_fret, next_fret_span) = match next_node {\r\n        Node::Start => unreachable!(\"Start should never be a future node.\"),\r\n        Node::Rest { .. } => return 0,\r\n        Node::Note {\r\n            beat_fingering_combo,\r\n            ..\r\n        } => (\r\n            beat_fingering_combo.non_zero_avg_fret,\r\n            beat_fingering_combo.non_zero_fret_span,\r\n        ),\r\n    };\r\n\r\n    let avg_fret_difference = (next_avg_fret - current_avg_fret).abs();\r\n\r\n    (avg_fret_difference * 10.0) as i16 + next_fret_span as i16\r\n}\r\n#[cfg(test)]\r\nmod test_calculate_node_cost {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn simple_no_diff() {\r\n        let current_node = Node::Note {\r\n            line_index: 0,\r\n            beat_fingering_combo: BeatFingeringCombo {\r\n                fingering_combo: vec![],\r\n                non_zero_avg_fret: OrderedFloat(3.5),\r\n                non_zero_fret_span: 0,\r\n            },\r\n        };\r\n        let next_node = Node::Note {\r\n            line_index: 1,\r\n            beat_fingering_combo: BeatFingeringCombo {\r\n                fingering_combo: vec![],\r\n                non_zero_avg_fret: OrderedFloat(3.5),\r\n                non_zero_fret_span: 0,\r\n            },\r\n        };\r\n\r\n        assert_eq!(calculate_node_cost(&current_node, &next_node), 0);\r\n    }\r\n    #[test]\r\n    fn simple_from_start() {\r\n        let next_node = Node::Note {\r\n            line_index: 1,\r\n            beat_fingering_combo: BeatFingeringCombo {\r\n                fingering_combo: vec![],\r\n                non_zero_avg_fret: OrderedFloat(3.5),\r\n                non_zero_fret_span: 0,\r\n            },\r\n        };\r\n\r\n        assert_eq!(calculate_node_cost(&Node::Start, &next_node), 0);\r\n    }\r\n    #[test]\r\n    fn simple_from_rest() {\r\n        let next_node = Node::Note {\r\n            line_index: 1,\r\n            beat_fingering_combo: BeatFingeringCombo {\r\n                fingering_combo: vec![],\r\n                non_zero_avg_fret: OrderedFloat(3.5),\r\n                non_zero_fret_span: 0,\r\n            },\r\n        };\r\n\r\n        assert_eq!(\r\n            calculate_node_cost(&Node::Rest { line_index: 0 }, &next_node),\r\n            0\r\n        );\r\n    }\r\n    #[test]\r\n    fn simple_to_rest() {\r\n        let current_node = Node::Note {\r\n            line_index: 0,\r\n            beat_fingering_combo: BeatFingeringCombo {\r\n                fingering_combo: vec![],\r\n                non_zero_avg_fret: OrderedFloat(3.5),\r\n                non_zero_fret_span: 0,\r\n            },\r\n        };\r\n\r\n        assert_eq!(\r\n            calculate_node_cost(&current_node, &Node::Rest { line_index: 1 }),\r\n            0\r\n        );\r\n    }\r\n    #[test]\r\n    fn simple_avg_fret_diff() {\r\n        let current_node = Node::Note {\r\n            line_index: 0,\r\n            beat_fingering_combo: BeatFingeringCombo {\r\n                fingering_combo: vec![],\r\n                non_zero_avg_fret: OrderedFloat(3.0),\r\n                non_zero_fret_span: 0,\r\n            },\r\n        };\r\n        let next_node = Node::Note {\r\n            line_index: 1,\r\n            beat_fingering_combo: BeatFingeringCombo {\r\n                fingering_combo: vec![],\r\n                non_zero_avg_fret: OrderedFloat(1.6),\r\n                non_zero_fret_span: 0,\r\n            },\r\n        };\r\n\r\n        assert_eq!(calculate_node_cost(&current_node, &next_node), 14);\r\n    }\r\n    #[test]\r\n    fn simple_fret_span() {\r\n        let current_node = Node::Note {\r\n            line_index: 0,\r\n            beat_fingering_combo: BeatFingeringCombo {\r\n                fingering_combo: vec![],\r\n                non_zero_avg_fret: OrderedFloat(4.133333),\r\n                non_zero_fret_span: 0,\r\n            },\r\n        };\r\n        let next_node = Node::Note {\r\n            line_index: 1,\r\n            beat_fingering_combo: BeatFingeringCombo {\r\n                fingering_combo: vec![],\r\n                non_zero_avg_fret: OrderedFloat(4.133333),\r\n                non_zero_fret_span: 3,\r\n            },\r\n        };\r\n\r\n        assert_eq!(calculate_node_cost(&current_node, &next_node), 3);\r\n    }\r\n    #[test]\r\n    fn compound() {\r\n        let current_node = Node::Note {\r\n            line_index: 0,\r\n            beat_fingering_combo: BeatFingeringCombo {\r\n                fingering_combo: vec![],\r\n                non_zero_avg_fret: OrderedFloat(5.0),\r\n                non_zero_fret_span: 0,\r\n            },\r\n        };\r\n        let next_node = Node::Note {\r\n            line_index: 1,\r\n            beat_fingering_combo: BeatFingeringCombo {\r\n                fingering_combo: vec![],\r\n                non_zero_avg_fret: OrderedFloat(2.0),\r\n                non_zero_fret_span: 5,\r\n            },\r\n        };\r\n\r\n        assert_eq!(calculate_node_cost(&current_node, &next_node), 35);\r\n    }\r\n    #[test]\r\n    fn complex() {\r\n        let current_node = Node::Note {\r\n            line_index: 0,\r\n            beat_fingering_combo: BeatFingeringCombo {\r\n                fingering_combo: vec![],\r\n                non_zero_avg_fret: OrderedFloat(7.3333333),\r\n                non_zero_fret_span: 0,\r\n            },\r\n        };\r\n        let next_node = Node::Note {\r\n            line_index: 1,\r\n            beat_fingering_combo: BeatFingeringCombo {\r\n                fingering_combo: vec![],\r\n                non_zero_avg_fret: OrderedFloat(3.6666666),\r\n                non_zero_fret_span: 4,\r\n            },\r\n        };\r\n\r\n        assert_eq!(calculate_node_cost(&current_node, &next_node), 40);\r\n    }\r\n}\r\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":706,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":710,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":715,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":717,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":718,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":723,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":914,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":915,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":916,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":917,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":919,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":920,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":921,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":924,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":926,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":928,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":929,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":930,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":931,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":932,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":936,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":938,"address":[],"length":0,"stats":{"Line":7},"fn_name":null}],"covered":75,"coverable":117},{"path":["C:","\\","Users","Noah","Documents","GitHub","guitar-tab-generator","src","guitar.rs"],"content":"use crate::{arrangement::PitchVec, Pitch, StringNumber};\r\nuse anyhow::{anyhow, Result};\r\nuse std::{\r\n    collections::{BTreeMap, HashSet},\r\n    fmt,\r\n};\r\nuse strum::IntoEnumIterator;\r\n\r\n#[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord)]\r\npub struct PitchFingering {\r\n    pub pitch: Pitch,\r\n    pub string_number: StringNumber,\r\n    pub fret: u8,\r\n}\r\nimpl fmt::Debug for PitchFingering {\r\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\r\n        write!(\r\n            f,\r\n            \"{} | {:?} ⇒ {}\",\r\n            self.pitch, self.string_number, self.fret\r\n        )\r\n    }\r\n}\r\n#[cfg(test)]\r\nmod test_pitch_fingering_debug {\r\n    use super::*;\r\n    #[test]\r\n    fn simple() {\r\n        let pitch_fingering = PitchFingering {\r\n            pitch: Pitch::ASharp4,\r\n            string_number: StringNumber::new(2).unwrap(),\r\n            fret: 3,\r\n        };\r\n\r\n        assert_eq!(format!(\"{:?}\", pitch_fingering), \"A#4 | 2_B ⇒ 3\");\r\n    }\r\n}\r\n\r\n#[derive(Debug, PartialEq)]\r\npub struct Guitar {\r\n    pub tuning: BTreeMap<StringNumber, Pitch>,\r\n    pub num_frets: u8,\r\n    pub range: HashSet<Pitch>,\r\n    pub string_ranges: BTreeMap<StringNumber, Vec<Pitch>>,\r\n}\r\nimpl Guitar {\r\n    pub fn new(tuning: BTreeMap<StringNumber, Pitch>, num_frets: u8) -> Result<Self> {\r\n        check_fret_number(num_frets)?;\r\n\r\n        let mut string_ranges: BTreeMap<StringNumber, Vec<Pitch>> = BTreeMap::new();\r\n        for (string_number, string_open_pitch) in tuning.iter() {\r\n            string_ranges.insert(\r\n                string_number.clone().to_owned(),\r\n                create_string_range(string_open_pitch, num_frets)?,\r\n            );\r\n        }\r\n\r\n        let range = string_ranges.clone().into_iter().fold(\r\n            HashSet::new(),\r\n            |mut all_pitches, string_pitches| {\r\n                all_pitches.extend(string_pitches.1);\r\n                all_pitches\r\n            },\r\n        );\r\n\r\n        Ok(Guitar {\r\n            tuning,\r\n            num_frets,\r\n            range,\r\n            string_ranges,\r\n        })\r\n    }\r\n}\r\n#[cfg(test)]\r\nmod test_create_guitar {\r\n    use super::*;\r\n\r\n    fn create_default_tuning() -> BTreeMap<StringNumber, Pitch> {\r\n        BTreeMap::from([\r\n            (StringNumber::new(1).unwrap(), Pitch::E4),\r\n            (StringNumber::new(2).unwrap(), Pitch::B3),\r\n            (StringNumber::new(3).unwrap(), Pitch::G3),\r\n            (StringNumber::new(4).unwrap(), Pitch::D3),\r\n            (StringNumber::new(5).unwrap(), Pitch::A2),\r\n            (StringNumber::new(6).unwrap(), Pitch::E2),\r\n        ])\r\n    }\r\n\r\n    #[test]\r\n    fn valid_simple() -> Result<()> {\r\n        let tuning = create_default_tuning();\r\n\r\n        const NUM_FRETS: u8 = 3;\r\n\r\n        let expected_guitar = Guitar {\r\n            tuning: tuning.clone(),\r\n            num_frets: NUM_FRETS,\r\n            range: HashSet::from([\r\n                Pitch::E2,\r\n                Pitch::F2,\r\n                Pitch::FSharp2,\r\n                Pitch::G2,\r\n                Pitch::A2,\r\n                Pitch::ASharp2,\r\n                Pitch::B2,\r\n                Pitch::C3,\r\n                Pitch::D3,\r\n                Pitch::DSharp3,\r\n                Pitch::E3,\r\n                Pitch::F3,\r\n                Pitch::G3,\r\n                Pitch::GSharp3,\r\n                Pitch::A3,\r\n                Pitch::ASharp3,\r\n                Pitch::B3,\r\n                Pitch::C4,\r\n                Pitch::CSharp4,\r\n                Pitch::D4,\r\n                Pitch::E4,\r\n                Pitch::F4,\r\n                Pitch::FSharp4,\r\n                Pitch::G4,\r\n            ]),\r\n            string_ranges: BTreeMap::from([\r\n                (\r\n                    StringNumber::new(1).unwrap(),\r\n                    vec![Pitch::E4, Pitch::F4, Pitch::FSharp4, Pitch::G4],\r\n                ),\r\n                (\r\n                    StringNumber::new(2).unwrap(),\r\n                    vec![Pitch::B3, Pitch::C4, Pitch::CSharp4, Pitch::D4],\r\n                ),\r\n                (\r\n                    StringNumber::new(3).unwrap(),\r\n                    vec![Pitch::G3, Pitch::GSharp3, Pitch::A3, Pitch::ASharp3],\r\n                ),\r\n                (\r\n                    StringNumber::new(4).unwrap(),\r\n                    vec![Pitch::D3, Pitch::DSharp3, Pitch::E3, Pitch::F3],\r\n                ),\r\n                (\r\n                    StringNumber::new(5).unwrap(),\r\n                    vec![Pitch::A2, Pitch::ASharp2, Pitch::B2, Pitch::C3],\r\n                ),\r\n                (\r\n                    StringNumber::new(6).unwrap(),\r\n                    vec![Pitch::E2, Pitch::F2, Pitch::FSharp2, Pitch::G2],\r\n                ),\r\n            ]),\r\n        };\r\n\r\n        assert_eq!(Guitar::new(tuning, NUM_FRETS)?, expected_guitar);\r\n\r\n        Ok(())\r\n    }\r\n    #[test]\r\n    fn valid_normal() -> Result<()> {\r\n        let tuning = create_default_tuning();\r\n\r\n        const NUM_FRETS: u8 = 18;\r\n\r\n        let expected_guitar = Guitar {\r\n            tuning: tuning.clone(),\r\n            num_frets: NUM_FRETS,\r\n            range: HashSet::from([\r\n                Pitch::E2,\r\n                Pitch::F2,\r\n                Pitch::FSharp2,\r\n                Pitch::G2,\r\n                Pitch::GSharp2,\r\n                Pitch::A2,\r\n                Pitch::ASharp2,\r\n                Pitch::B2,\r\n                Pitch::C3,\r\n                Pitch::CSharp3,\r\n                Pitch::D3,\r\n                Pitch::DSharp3,\r\n                Pitch::E3,\r\n                Pitch::F3,\r\n                Pitch::FSharp3,\r\n                Pitch::G3,\r\n                Pitch::GSharp3,\r\n                Pitch::A3,\r\n                Pitch::ASharp3,\r\n                Pitch::B3,\r\n                Pitch::C4,\r\n                Pitch::CSharp4,\r\n                Pitch::D4,\r\n                Pitch::DSharp4,\r\n                Pitch::E4,\r\n                Pitch::F4,\r\n                Pitch::FSharp4,\r\n                Pitch::G4,\r\n                Pitch::GSharp4,\r\n                Pitch::A4,\r\n                Pitch::ASharp4,\r\n                Pitch::B4,\r\n                Pitch::C5,\r\n                Pitch::CSharp5,\r\n                Pitch::D5,\r\n                Pitch::DSharp5,\r\n                Pitch::E5,\r\n                Pitch::F5,\r\n                Pitch::FSharp5,\r\n                Pitch::G5,\r\n                Pitch::GSharp5,\r\n                Pitch::A5,\r\n                Pitch::ASharp5,\r\n            ]),\r\n            string_ranges: BTreeMap::from([\r\n                (\r\n                    StringNumber::new(1).unwrap(),\r\n                    vec![\r\n                        Pitch::E4,\r\n                        Pitch::F4,\r\n                        Pitch::FSharp4,\r\n                        Pitch::G4,\r\n                        Pitch::GSharp4,\r\n                        Pitch::A4,\r\n                        Pitch::ASharp4,\r\n                        Pitch::B4,\r\n                        Pitch::C5,\r\n                        Pitch::CSharp5,\r\n                        Pitch::D5,\r\n                        Pitch::DSharp5,\r\n                        Pitch::E5,\r\n                        Pitch::F5,\r\n                        Pitch::FSharp5,\r\n                        Pitch::G5,\r\n                        Pitch::GSharp5,\r\n                        Pitch::A5,\r\n                        Pitch::ASharp5,\r\n                    ],\r\n                ),\r\n                (\r\n                    StringNumber::new(2).unwrap(),\r\n                    vec![\r\n                        Pitch::B3,\r\n                        Pitch::C4,\r\n                        Pitch::CSharp4,\r\n                        Pitch::D4,\r\n                        Pitch::DSharp4,\r\n                        Pitch::E4,\r\n                        Pitch::F4,\r\n                        Pitch::FSharp4,\r\n                        Pitch::G4,\r\n                        Pitch::GSharp4,\r\n                        Pitch::A4,\r\n                        Pitch::ASharp4,\r\n                        Pitch::B4,\r\n                        Pitch::C5,\r\n                        Pitch::CSharp5,\r\n                        Pitch::D5,\r\n                        Pitch::DSharp5,\r\n                        Pitch::E5,\r\n                        Pitch::F5,\r\n                    ],\r\n                ),\r\n                (\r\n                    StringNumber::new(3).unwrap(),\r\n                    vec![\r\n                        Pitch::G3,\r\n                        Pitch::GSharp3,\r\n                        Pitch::A3,\r\n                        Pitch::ASharp3,\r\n                        Pitch::B3,\r\n                        Pitch::C4,\r\n                        Pitch::CSharp4,\r\n                        Pitch::D4,\r\n                        Pitch::DSharp4,\r\n                        Pitch::E4,\r\n                        Pitch::F4,\r\n                        Pitch::FSharp4,\r\n                        Pitch::G4,\r\n                        Pitch::GSharp4,\r\n                        Pitch::A4,\r\n                        Pitch::ASharp4,\r\n                        Pitch::B4,\r\n                        Pitch::C5,\r\n                        Pitch::CSharp5,\r\n                    ],\r\n                ),\r\n                (\r\n                    StringNumber::new(4).unwrap(),\r\n                    vec![\r\n                        Pitch::D3,\r\n                        Pitch::DSharp3,\r\n                        Pitch::E3,\r\n                        Pitch::F3,\r\n                        Pitch::FSharp3,\r\n                        Pitch::G3,\r\n                        Pitch::GSharp3,\r\n                        Pitch::A3,\r\n                        Pitch::ASharp3,\r\n                        Pitch::B3,\r\n                        Pitch::C4,\r\n                        Pitch::CSharp4,\r\n                        Pitch::D4,\r\n                        Pitch::DSharp4,\r\n                        Pitch::E4,\r\n                        Pitch::F4,\r\n                        Pitch::FSharp4,\r\n                        Pitch::G4,\r\n                        Pitch::GSharp4,\r\n                    ],\r\n                ),\r\n                (\r\n                    StringNumber::new(5).unwrap(),\r\n                    vec![\r\n                        Pitch::A2,\r\n                        Pitch::ASharp2,\r\n                        Pitch::B2,\r\n                        Pitch::C3,\r\n                        Pitch::CSharp3,\r\n                        Pitch::D3,\r\n                        Pitch::DSharp3,\r\n                        Pitch::E3,\r\n                        Pitch::F3,\r\n                        Pitch::FSharp3,\r\n                        Pitch::G3,\r\n                        Pitch::GSharp3,\r\n                        Pitch::A3,\r\n                        Pitch::ASharp3,\r\n                        Pitch::B3,\r\n                        Pitch::C4,\r\n                        Pitch::CSharp4,\r\n                        Pitch::D4,\r\n                        Pitch::DSharp4,\r\n                    ],\r\n                ),\r\n                (\r\n                    StringNumber::new(6).unwrap(),\r\n                    vec![\r\n                        Pitch::E2,\r\n                        Pitch::F2,\r\n                        Pitch::FSharp2,\r\n                        Pitch::G2,\r\n                        Pitch::GSharp2,\r\n                        Pitch::A2,\r\n                        Pitch::ASharp2,\r\n                        Pitch::B2,\r\n                        Pitch::C3,\r\n                        Pitch::CSharp3,\r\n                        Pitch::D3,\r\n                        Pitch::DSharp3,\r\n                        Pitch::E3,\r\n                        Pitch::F3,\r\n                        Pitch::FSharp3,\r\n                        Pitch::G3,\r\n                        Pitch::GSharp3,\r\n                        Pitch::A3,\r\n                        Pitch::ASharp3,\r\n                    ],\r\n                ),\r\n            ]),\r\n        };\r\n\r\n        assert_eq!(Guitar::new(tuning, NUM_FRETS)?, expected_guitar);\r\n\r\n        Ok(())\r\n    }\r\n    #[test]\r\n    fn invalid_num_frets() {\r\n        assert!(Guitar::new(create_default_tuning(), 35).is_err());\r\n    }\r\n}\r\n\r\n/// Check if the number of frets is within a maximum limit and returns an error if it exceeds the limit.\r\nfn check_fret_number(num_frets: u8) -> Result<()> {\r\n    const MAX_NUM_FRETS: u8 = 30;\r\n    if num_frets > MAX_NUM_FRETS {\r\n        return Err(anyhow!(\r\n            \"Too many frets ({num_frets}). The maximum is {MAX_NUM_FRETS}.\"\r\n        ));\r\n    }\r\n\r\n    Ok(())\r\n}\r\n#[cfg(test)]\r\nmod test_check_fret_number {\r\n    use super::*;\r\n    #[test]\r\n    fn valid() {\r\n        assert!(check_fret_number(0).is_ok());\r\n        assert!(check_fret_number(2).is_ok());\r\n        assert!(check_fret_number(7).is_ok());\r\n        assert!(check_fret_number(20).is_ok());\r\n    }\r\n    #[test]\r\n    fn invalid() {\r\n        assert!(check_fret_number(0).is_ok());\r\n        assert!(check_fret_number(12).is_ok());\r\n        assert!(check_fret_number(18).is_ok());\r\n        assert!(check_fret_number(27).is_ok());\r\n        assert!(check_fret_number(31).is_err());\r\n        assert!(check_fret_number(100).is_err());\r\n    }\r\n}\r\n\r\n/// Generates a vector of pitches representing the range of the string.\r\n///\r\n/// Arguments:\r\n///\r\n/// * `open_string_pitch`: The `open_string_pitch` parameter represents the pitch of the open\r\n/// string.\r\n/// * `num_frets`: The `num_frets` parameter represents the number of\r\n///   subsequent number of half steps to include in the range.\r\nfn create_string_range(open_string_pitch: &Pitch, num_frets: u8) -> Result<Vec<Pitch>> {\r\n    let lowest_pitch_index = Pitch::iter().position(|x| &x == open_string_pitch).unwrap();\r\n\r\n    let all_pitches_vec: Vec<Pitch> = Pitch::iter().collect();\r\n    let string_range_result =\r\n        all_pitches_vec.get(lowest_pitch_index..=lowest_pitch_index + num_frets as usize);\r\n\r\n    match string_range_result {\r\n        Some(string_range_slice) => Ok(string_range_slice.to_vec()),\r\n        None => {\r\n            let highest_pitch = all_pitches_vec\r\n                .last()\r\n                .expect(\"The Pitch enum should not be empty.\");\r\n            let highest_pitch_fret = highest_pitch.index() - open_string_pitch.index();\r\n            let err_msg = format!(\"Too many frets ({num_frets}) for string starting at pitch {open_string_pitch}. \\\r\n                The highest pitch is {highest_pitch}, which would only exist at fret number {highest_pitch_fret}.\");\r\n\r\n            Err(anyhow!(err_msg))\r\n        }\r\n    }\r\n}\r\n#[cfg(test)]\r\nmod test_create_string_range {\r\n    use super::*;\r\n    #[test]\r\n    fn valid() -> Result<()> {\r\n        assert_eq!(create_string_range(&Pitch::E2, 0)?, vec![Pitch::E2]);\r\n        assert_eq!(\r\n            create_string_range(&Pitch::E2, 3)?,\r\n            vec![Pitch::E2, Pitch::F2, Pitch::FSharp2, Pitch::G2]\r\n        );\r\n        assert_eq!(\r\n            create_string_range(&Pitch::E2, 12)?,\r\n            vec![\r\n                Pitch::E2,\r\n                Pitch::F2,\r\n                Pitch::FSharp2,\r\n                Pitch::G2,\r\n                Pitch::GSharp2,\r\n                Pitch::A2,\r\n                Pitch::ASharp2,\r\n                Pitch::B2,\r\n                Pitch::C3,\r\n                Pitch::CSharp3,\r\n                Pitch::D3,\r\n                Pitch::DSharp3,\r\n                Pitch::E3\r\n            ]\r\n        );\r\n        Ok(())\r\n    }\r\n    #[test]\r\n    fn invalid() {\r\n        let error = create_string_range(&Pitch::G9, 5).unwrap_err();\r\n        let error_string = format!(\"{error}\");\r\n        let expected_error_string = \"Too many frets (5) for string starting at pitch G9. The highest pitch is B9, which would only exist at fret number 4.\";\r\n        assert_eq!(error_string, expected_error_string);\r\n\r\n        let error = create_string_range(&Pitch::E2, 100).unwrap_err();\r\n        let error_string = format!(\"{error}\");\r\n        let expected_error_string = \"Too many frets (100) for string starting at pitch E2. The highest pitch is B9, which would only exist at fret number 91.\";\r\n        assert_eq!(error_string, expected_error_string);\r\n    }\r\n}\r\n\r\n/// Takes a pitch as input and returns the fingerings for that pitch on each\r\n///string of the guitar given its tuning.\r\n///\r\n/// If no fingerings are possible on any of the strings of the guitar, an\r\n/// empty vector is returned.\r\n// TODO benchmark memoization\r\npub fn generate_pitch_fingerings(\r\n    string_ranges: &BTreeMap<StringNumber, Vec<Pitch>>,\r\n    pitch: &Pitch,\r\n) -> PitchVec<PitchFingering> {\r\n    let fingerings: PitchVec<PitchFingering> = string_ranges\r\n        .iter()\r\n        .filter_map(|(string_number, string_range)| {\r\n            string_range\r\n                .iter()\r\n                .position(|x| x == pitch)\r\n                .map(|fret_number| PitchFingering {\r\n                    pitch: *pitch,\r\n                    string_number: *string_number,\r\n                    fret: fret_number as u8,\r\n                })\r\n        })\r\n        .collect();\r\n    // dbg!(&fingerings);\r\n\r\n    // let non_zero_fret_avg =\r\n    //     non_zero_frets.iter().sum::<usize>() as f32 / non_zero_frets.len() as f32;\r\n\r\n    fingerings\r\n}\r\n#[cfg(test)]\r\nmod test_generate_pitch_fingering {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn valid_normal() -> Result<()> {\r\n        const NUM_FRETS: u8 = 12;\r\n        let string_ranges = BTreeMap::from([\r\n            (\r\n                StringNumber::new(1).unwrap(),\r\n                create_string_range(&Pitch::E4, NUM_FRETS)?,\r\n            ),\r\n            (\r\n                StringNumber::new(2).unwrap(),\r\n                create_string_range(&Pitch::B3, NUM_FRETS)?,\r\n            ),\r\n            (\r\n                StringNumber::new(3).unwrap(),\r\n                create_string_range(&Pitch::G3, NUM_FRETS)?,\r\n            ),\r\n            (\r\n                StringNumber::new(4).unwrap(),\r\n                create_string_range(&Pitch::D3, NUM_FRETS)?,\r\n            ),\r\n            (\r\n                StringNumber::new(5).unwrap(),\r\n                create_string_range(&Pitch::A2, NUM_FRETS)?,\r\n            ),\r\n            (\r\n                StringNumber::new(6).unwrap(),\r\n                create_string_range(&Pitch::E2, NUM_FRETS)?,\r\n            ),\r\n        ]);\r\n\r\n        assert_eq!(\r\n            generate_pitch_fingerings(&string_ranges, &Pitch::E2),\r\n            vec![PitchFingering {\r\n                pitch: Pitch::E2,\r\n                string_number: StringNumber::new(6).unwrap(),\r\n                fret: 0\r\n            }]\r\n        );\r\n        assert_eq!(\r\n            generate_pitch_fingerings(&string_ranges, &Pitch::D3),\r\n            vec![\r\n                PitchFingering {\r\n                    pitch: Pitch::D3,\r\n                    string_number: StringNumber::new(4).unwrap(),\r\n                    fret: 0\r\n                },\r\n                PitchFingering {\r\n                    pitch: Pitch::D3,\r\n                    string_number: StringNumber::new(5).unwrap(),\r\n                    fret: 5\r\n                },\r\n                PitchFingering {\r\n                    pitch: Pitch::D3,\r\n                    string_number: StringNumber::new(6).unwrap(),\r\n                    fret: 10\r\n                }\r\n            ]\r\n        );\r\n        assert_eq!(\r\n            generate_pitch_fingerings(&string_ranges, &Pitch::CSharp4),\r\n            vec![\r\n                PitchFingering {\r\n                    pitch: Pitch::CSharp4,\r\n                    string_number: StringNumber::new(2).unwrap(),\r\n                    fret: 2\r\n                },\r\n                PitchFingering {\r\n                    pitch: Pitch::CSharp4,\r\n                    string_number: StringNumber::new(3).unwrap(),\r\n                    fret: 6\r\n                },\r\n                PitchFingering {\r\n                    pitch: Pitch::CSharp4,\r\n                    string_number: StringNumber::new(4).unwrap(),\r\n                    fret: 11\r\n                }\r\n            ]\r\n        );\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn valid_simple() -> Result<()> {\r\n        const NUM_FRETS: u8 = 12;\r\n        let string_ranges = BTreeMap::from([\r\n            (\r\n                StringNumber::new(1).unwrap(),\r\n                create_string_range(&Pitch::G4, NUM_FRETS)?,\r\n            ),\r\n            (\r\n                StringNumber::new(2).unwrap(),\r\n                create_string_range(&Pitch::DSharp4, NUM_FRETS)?,\r\n            ),\r\n        ]);\r\n\r\n        assert_eq!(\r\n            generate_pitch_fingerings(&string_ranges, &Pitch::DSharp4),\r\n            vec![PitchFingering {\r\n                pitch: Pitch::DSharp4,\r\n                string_number: StringNumber::new(2).unwrap(),\r\n                fret: 0\r\n            }]\r\n        );\r\n        assert_eq!(\r\n            generate_pitch_fingerings(&string_ranges, &Pitch::ASharp4),\r\n            vec![\r\n                PitchFingering {\r\n                    pitch: Pitch::ASharp4,\r\n                    string_number: StringNumber::new(1).unwrap(),\r\n                    fret: 3\r\n                },\r\n                PitchFingering {\r\n                    pitch: Pitch::ASharp4,\r\n                    string_number: StringNumber::new(2).unwrap(),\r\n                    fret: 7\r\n                }\r\n            ]\r\n        );\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn valid_few_frets() -> Result<()> {\r\n        const NUM_FRETS: u8 = 2;\r\n        let string_ranges = BTreeMap::from([\r\n            (\r\n                StringNumber::new(1).unwrap(),\r\n                create_string_range(&Pitch::E4, NUM_FRETS)?,\r\n            ),\r\n            (\r\n                StringNumber::new(2).unwrap(),\r\n                create_string_range(&Pitch::B3, NUM_FRETS)?,\r\n            ),\r\n            (\r\n                StringNumber::new(3).unwrap(),\r\n                create_string_range(&Pitch::G3, NUM_FRETS)?,\r\n            ),\r\n            (\r\n                StringNumber::new(4).unwrap(),\r\n                create_string_range(&Pitch::D3, NUM_FRETS)?,\r\n            ),\r\n            (\r\n                StringNumber::new(5).unwrap(),\r\n                create_string_range(&Pitch::A2, NUM_FRETS)?,\r\n            ),\r\n            (\r\n                StringNumber::new(6).unwrap(),\r\n                create_string_range(&Pitch::E2, NUM_FRETS)?,\r\n            ),\r\n        ]);\r\n\r\n        assert_eq!(\r\n            generate_pitch_fingerings(&string_ranges, &Pitch::E3),\r\n            vec![PitchFingering {\r\n                pitch: Pitch::E3,\r\n                string_number: StringNumber::new(4).unwrap(),\r\n                fret: 2\r\n            }]\r\n        );\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn valid_impossible_pitch() -> Result<()> {\r\n        const NUM_FRETS: u8 = 12;\r\n        let string_ranges = BTreeMap::from([\r\n            (\r\n                StringNumber::new(1).unwrap(),\r\n                create_string_range(&Pitch::E4, NUM_FRETS)?,\r\n            ),\r\n            (\r\n                StringNumber::new(2).unwrap(),\r\n                create_string_range(&Pitch::B3, NUM_FRETS)?,\r\n            ),\r\n            (\r\n                StringNumber::new(3).unwrap(),\r\n                create_string_range(&Pitch::G3, NUM_FRETS)?,\r\n            ),\r\n            (\r\n                StringNumber::new(4).unwrap(),\r\n                create_string_range(&Pitch::D3, NUM_FRETS)?,\r\n            ),\r\n            (\r\n                StringNumber::new(5).unwrap(),\r\n                create_string_range(&Pitch::A2, NUM_FRETS)?,\r\n            ),\r\n            (\r\n                StringNumber::new(6).unwrap(),\r\n                create_string_range(&Pitch::E2, NUM_FRETS)?,\r\n            ),\r\n        ]);\r\n\r\n        assert_eq!(\r\n            generate_pitch_fingerings(&string_ranges, &Pitch::D2),\r\n            vec![]\r\n        );\r\n        assert_eq!(\r\n            generate_pitch_fingerings(&string_ranges, &Pitch::F5),\r\n            vec![]\r\n        );\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":1649},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":188},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":160},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":160},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":1157},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":186},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":28},"fn_name":null}],"covered":46,"coverable":46},{"path":["C:","\\","Users","Noah","Documents","GitHub","guitar-tab-generator","src","pitch.rs"],"content":"use std::fmt;\nuse strum_macros::{EnumIter, EnumString, FromRepr};\n\n#[derive(\n    Debug, Clone, Copy, Hash, Eq, PartialEq, Ord, PartialOrd, EnumIter, FromRepr, EnumString,\n)]\npub enum Pitch {\n    C0,\n    CSharp0,\n    D0,\n    DSharp0,\n    E0,\n    F0,\n    FSharp0,\n    G0,\n    GSharp0,\n    A0,\n    ASharp0,\n    B0,\n    C1,\n    CSharp1,\n    D1,\n    DSharp1,\n    E1,\n    F1,\n    FSharp1,\n    G1,\n    GSharp1,\n    A1,\n    ASharp1,\n    B1,\n    C2,\n    CSharp2,\n    D2,\n    DSharp2,\n    E2,\n    F2,\n    FSharp2,\n    G2,\n    GSharp2,\n    A2,\n    ASharp2,\n    B2,\n    C3,\n    CSharp3,\n    D3,\n    DSharp3,\n    E3,\n    F3,\n    FSharp3,\n    G3,\n    GSharp3,\n    A3,\n    ASharp3,\n    B3,\n    C4,\n    CSharp4,\n    D4,\n    DSharp4,\n    E4,\n    F4,\n    FSharp4,\n    G4,\n    GSharp4,\n    A4,\n    ASharp4,\n    B4,\n    C5,\n    CSharp5,\n    D5,\n    DSharp5,\n    E5,\n    F5,\n    FSharp5,\n    G5,\n    GSharp5,\n    A5,\n    ASharp5,\n    B5,\n    C6,\n    CSharp6,\n    D6,\n    DSharp6,\n    E6,\n    F6,\n    FSharp6,\n    G6,\n    GSharp6,\n    A6,\n    ASharp6,\n    B6,\n    C7,\n    CSharp7,\n    D7,\n    DSharp7,\n    E7,\n    F7,\n    FSharp7,\n    G7,\n    GSharp7,\n    A7,\n    ASharp7,\n    B7,\n    C8,\n    CSharp8,\n    D8,\n    DSharp8,\n    E8,\n    F8,\n    FSharp8,\n    G8,\n    GSharp8,\n    A8,\n    ASharp8,\n    B8,\n    C9,\n    CSharp9,\n    D9,\n    DSharp9,\n    E9,\n    F9,\n    FSharp9,\n    G9,\n    GSharp9,\n    A9,\n    ASharp9,\n    B9,\n}\nimpl fmt::Display for Pitch {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let pitch_w_pretty_sharp = format!(\"{:?}\", self).replace(\"Sharp\", \"#\");\n        write!(f, \"{}\", pitch_w_pretty_sharp)\n    }\n}\n#[cfg(test)]\nmod test_pitch_display {\n    use super::*;\n    #[test]\n    fn valid_simple() {\n        assert_eq!(format!(\"{}\", Pitch::E2), \"E2\");\n        assert_eq!(format!(\"{}\", Pitch::DSharp3), \"D#3\");\n    }\n}\n\nimpl Pitch {\n    pub fn index(&self) -> u8 {\n        *self as u8\n    }\n}\n","traces":[{"line":130,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":4},"fn_name":null}],"covered":5,"coverable":5},{"path":["C:","\\","Users","Noah","Documents","GitHub","guitar-tab-generator","src","string_number.rs"],"content":"use anyhow::{anyhow, Result};\nuse std::fmt;\n\n#[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord)]\npub struct StringNumber(u8);\nimpl StringNumber {\n    pub fn new(string_number: u8) -> Result<Self> {\n        const MAX_NUM_STRINGS: u8 = 12;\n        match string_number {\n            0 => Err(anyhow!(\"A guitar cannot have a string number of zero (0). Guitar string numbering commences at one (1).\")),\n            1..=MAX_NUM_STRINGS => Ok(StringNumber(string_number)),\n            _ => Err(anyhow!(\"The string number ({string_number}) is too high. The maximum is {MAX_NUM_STRINGS}.\"))\n\n        }\n    }\n}\n#[cfg(test)]\nmod test_create_string_number {\n    use super::*;\n    #[test]\n    fn valid_simple() {\n        assert!(StringNumber::new(1).is_ok());\n    }\n    #[test]\n    fn invalid_zero() {\n        let expected_error_string = \"A guitar cannot have a string number of zero (0). Guitar string numbering commences at one (1).\";\n        let error = StringNumber::new(0).unwrap_err();\n        assert_eq!(format!(\"{error}\"), expected_error_string);\n    }\n    #[test]\n    fn invalid_too_high() {\n        let expected_error_string = \"The string number (15) is too high. The maximum is 12.\";\n        let error = StringNumber::new(15).unwrap_err();\n        assert_eq!(format!(\"{error}\"), expected_error_string);\n    }\n}\n\nimpl fmt::Debug for StringNumber {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        // write!(f, \"{}\", self.0)\n        let string_number = self.0;\n        let string_pitch_letter = match string_number {\n            1 => \"1_e\".to_owned(),\n            2 => \"2_B\".to_owned(),\n            3 => \"3_G\".to_owned(),\n            4 => \"4_D\".to_owned(),\n            5 => \"5_A\".to_owned(),\n            6 => \"6_E\".to_owned(),\n            string_number => string_number.to_string(),\n        };\n        write!(f, \"{}\", string_pitch_letter)\n    }\n}\n#[cfg(test)]\nmod test_pitch_debug {\n    use super::*;\n    #[test]\n    fn strings_1_to_6() {\n        assert_eq!(format!(\"{:?}\", StringNumber::new(1).unwrap()), \"1_e\");\n        assert_eq!(format!(\"{:?}\", StringNumber::new(2).unwrap()), \"2_B\");\n        assert_eq!(format!(\"{:?}\", StringNumber::new(3).unwrap()), \"3_G\");\n        assert_eq!(format!(\"{:?}\", StringNumber::new(4).unwrap()), \"4_D\");\n        assert_eq!(format!(\"{:?}\", StringNumber::new(5).unwrap()), \"5_A\");\n        assert_eq!(format!(\"{:?}\", StringNumber::new(6).unwrap()), \"6_E\");\n    }\n    #[test]\n    fn string_greater_than_6() {\n        assert_eq!(format!(\"{:?}\", StringNumber::new(8).unwrap()), \"8\");\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":147},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":147},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":291},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":8},"fn_name":null}],"covered":16,"coverable":16}]}